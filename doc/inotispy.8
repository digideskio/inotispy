.\" Copyright (c) 2011-*, (mt) MediaTemple <mediatemple.net>
.\" All rights reserved.
.\" 
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 
.\"  - Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\"  - Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in
.\"    the documentation and/or other materials provided with the
.\"    distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
.\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
.\" LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CON-
.\" SEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
.\" GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.TH "INOTISPY" "8" "21 September 2011" "Inotispy 1\&.0\&.1" "Inotispy Manual"
.SH NAME
inotispy \- efficient inotify daemon
.SH SYNOPSIS
.B inotispy [options]
.SH DESCRIPTION
Inotispy is an efficient file system change notification daemon built on top
of the
.BR inotify
kernel module. It recursively watches directory trees, queues file system
events that occur within those trees, and delivers those events to client
applications via
.BR ZeroMQ
sockets.
.PP
Inotispy is written in the C programmaing language and was tested against
.BR valgrind (1)
for memory leaks.
.SH OPTIONS
Inotispy doesn't have many command line options. If you are interested
in further changing the behavior of Inotispy please see the \fBCONFIGURATION
FILE\fR section below.
.PP
\fB\-h\fR, \fB\-\-help\fR
.RS 4
Print the help menu.
.RE
\fB\-s\fR, \fB\-\-silent\fR
.RS 4
Run silently, and only messages will be appended to the log file. Inotispy
prints very little information to \fBstderr\fR and only does so at start up.
So this feature isn't very useful unless it's important that it runs with
nothing printed to the terminal.
.RE
.SH INOTISPY OVERVIEW
The \fBInotispy\fR daemon provides a service oriented interface for watching
directory trees on your file system for events. These events may include file
creation, deletion, move, permissions change, etc. Its interface and control
flow are designed to be as simple as possible. Essentially all a client does
is:
.P
.in +4n
1. \fBwatch\fR a directory tree for events.
.br
2. periodically \fBconsume\fR events from that directory tree.
.br
3. \fBunwatch\fR that tree when it's events are no longer of interest.
.P
.nf
    \fBwatch\fR--->\fBconsume\fR-.->\fBunwatch\fR
          ^          |
          |__________|
.fi
.in
.P
Inotispy's main goal is to make it so that you, the coder, the one with
the file system monitoring project, can hook into inotify without having
to write your own code to recursively watch directories, manage mappings
between paths and watch descriptors, and handle event queuing. 
.P
Also, Inotispy is a service which is completely decoupled from your
application. This means that you can bring your application down for
maintenance (or a code release) and you won't lose the events from the
directory trees your application was watching.
.P
Communication with Inotispy is done through \fBZeroMQ\fR sockets and the protocol
is \fBJSON\fR. Each JSON request must contain a \fIcall\fR field and then a set
of required and optional arguments, depending on the call.
.SS Calls
Calls to Inotispy are incredibly simple. An example call in JSON would look like:
.P
.in +4n
.nf
{
    "call" : "watch",
    "path" : "/foo/bar"
}
.fi
.in
.P
This call tells Inotispy to recursively watch all directories starting at the
root path \fI/foo/bar\fR and to start queuing up events for file system changes
that happen under that root.
.P
See the \fBINOTISPY API\fR section below for the full list of calls and their arguments.
.SS Responses
Responses from Inotispy are also JSON and they come in 3 flavors: \fBsuccess\fR,
\fBerror\fR, and \fBdata\fR.
.P
\fIsuccess\fR
.P
The \fBsuccess\fR response is actually pretty useless. This is the response you get
when you tell Inotispy to \fIwatch\fR or \fIunwatch\fR a directory tree and it
successfully kicks off the routine that recursively watches (or unwatches) your
tree. (As a client, what you're more interested in is an \fBerror\fR response.)
The \fBsuccess\fR response looks like:
.P
.RS 4
{ "success" : 1 }
.RE
.P
\fIerror\fR
.P
The \fBerror\fR response tells you that something went wrong with your request,
naturally, by returning you an \fBerror code\fR and an \fBerror message\fR. Since
any of the calls can generate an error a client should \fIalways\fR first check
the response to see if it contains an \fBerror\fR field, and then react accordingly.
It looks like:
.P
.in +4n
.nf
{
    "error" : {
        "code" : 124,
        "message" : "Foo failed because of bar"
    }
}
.fi
.in
.P
\fIdata\fR
.P
The \fBdata\fR response is what you get when you request information from Inotispy,
such as a call to \fBget_roots\fR or \fBget_events\fR. This will be a hash with one
key, \fIdata\fR, whose value is an array containing the data you requested.\fB*\fR
In the case of \fBget_roots\fR it will be an array of pathnames (strings). In the
case of \fBget_events\fR it will be an array of hashes where each hash contains the
data of an inotify event. (See \fBINOTISPY_API\fR below for more information). It
looks like:
.P
.in +4n
.nf
{
    "data" : [
        "/foo/bar",
        "/baz/bing/bong"
    ]
}
.fi
.in
.P
\fB*\fR The one exception to this is a call to \fBget_queue_size\fR where the
value of the data field is an integer, not an array, which will look like:
.P
.in +4n
.nf
{ "data" : 42 }
.fi
.in
.P
.SH INOTISPY API
.P
Here is the list of supported calls, and their arguments and return values.
.P
.SS watch
Watch a new directory tree.
.P
\fIRequired Arguments\fR
.br
\fBpath\fR       - Absolute path of the new directory tree you want to watch.
.P
\fIOptional Arguments\fR
.br
\fBmask\fR       - Inotify mask defining the file system events\fB*\fR
             you want to receive notifications for.\fB**\fR
.br
\fBmax_events\fR - Max number of inotify events to queue for
             this root. The default is 65536.
.P
\fIReturn Value\fR
.br
\fBsuccess\fR or \fBerror\fR
.P
\fIExample\fR
.P
.in +4n
.nf
{
    "call" : "watch",
    "path" : "/foo/bar",
    "mask": 1024,
    "max_events" : 1000
}
.fi
.in
.P
\fB*\fR If you don't supply your own mask Inotify provides a default mask for you.
The events in the default mask are:
.P
.in +4n
\fB
.nf
IN_ATTRIB
IN_MOVED_FROM
IN_MOVED_TO
IN_CREATE
IN_CLOSE_WRITE
IN_DELETE
IN_UNMOUNT
.fi
\fR
.in
.P
\fB**\fR See 
.BR inotify(7)
for more information on inotify events. A simple
(non-working) example in \fBC\fR for using a custom mask would look something like:
.P
.in +4n
.nf
#include <zmq.h>
#include <stdio.h>
#include <\fBsys/inotify.h\fR>

int
main (void) {
    uint32_t mask;
    char *json;
    char *path = "/foo/bar";

    /* Let's just watch for create and delete events */
    mask = \fBIN_CREATE\fR | \fBIN_DELETE\fR;

    asprintf(&json,
        "{\\"call\\":\\"watch\\",\\"path\\":%s,\fB\\"mask\\":%d\fR}",
        path, \fBmask\fR);

    /* Make 0MQ message from the 'json' variable here */

    zmq_send(socket, &msg, 0);
}
.fi
.in
.SS unwatch
Unwatch a currently watched directory tree.
.P
\fIRequired Arguments\fR
.br
\fBpath\fR - Absolute path of the root you want to unwatch.
.P
\fIReturn Value\fR
.br
\fBsuccess\fR or \fBerror\fR
.P
\fIExample\fR
.P
.in +4n
.nf
{
    "call" : "unwatch",
    "path" : "/foo/bar"
}
.fi
.in
.P
.SS get_roots
Get the list of currently watched roots (directory trees).
.P
\fIThis function takes NO arguments\fR
.P
\fIReturn Value\fR
.br
\fBdata\fR or \fBerror\fR
.P
\fIExample\fR
.P
.RS 4
{ "call" : "get_roots" }
.RE
.P
.SS get_queue_size
Get the number of events in a given root's queue.
.P
\fIRequired Arguments\fR
.br
\fBpath\fR - Absolute path of the root you wish to query.
.P
\fIReturn Value\fR
.br
\fBdata\fR or \fBerror\fR
.P
\fIExample\fR
.P
.in +4n
.nf
{
    "call" : "get_queue_size",
    "path" : "/foo/bar"
}
.fi
.in
.P
.SS get_events
Retrieve inotify events from a given root's queue.
.P
\fIRequired Arguments\fR
.br
\fBpath\fR  - Absolute path of the root you wish to retrieve events from.
.P
\fIOptional Arguments\fR
.br
\fBcount\fR - Number of events you want to retrieve.\fB*\fR
.P
\fIReturn Value\fR
.br
\fBdata\fR or \fBerror\fR
.P
\fIExample\fR
.P
.in +4n
.nf
{
    "call"  : "get_events",
    "path"  : "/foo/bar",
    "count" : 10
}
.fi
.in
.P
\fB*\fR Using a value of 0 (zero) will retrieve \fIall\fR events from
that root's queue.
.P
.SH EXAMPLES
For examples on writing a client to talk to Inotispy please take a look at the
\fBexamples/\fR directory that ships with the distribution. There are examples
in several languages, including \fBC\fR and \fBPerl\fR.
.P
If you're writing your client code in \fBC\fR a full blown example is
\fBbin/inotispyctl.c\fR. 
.SH CONFIGURATION FILE
Inotispy ships with a small configuration file that you can use to modify a few
of it's characteristics. The config file that comes with the distribution
(\fBetc/inotispy.conf\fR) is thoroughly documented and it's full contents will
not be repeated here. However, here is the high level rundown of the parameters
you can tweak:
.P
.RS 4
\fBsilent\fR             - toggle printing to stderr
.br
\fBport\fR               - set your own port
.br
\fBlog_file\fR           - path to log file
.br
\fBlog_level\fR          - set the verbosity of logging
.br
\fBlog_syslog\fR         - toggle log output to syslog
.br
\fBmax_inotify_events\fR - cap the number of per/root inotify
                     events to be queued
.RE
.SH LOGGING
Inotispy outputs runtime information to a private log file, and alternatively
to \fBsyslog\fR. The default location of the private log file is
\fB/var/log/inotispy.log\fR. Using the configuration file (described above)
you can change the location of this log file as well as change the level
of verbosity you want to see in the log. By default the level is set to
\fBnotice\fR, which should make the output fairly limited, and logging to
\fBsyslog\fR is set to \fBfalse\fR.
.P
If you want, or need, to see more of what's going on under the hood then change
that level to \fBdebug\fR or \fBtrace\fR. Just be warned that these two levels
can produce quite a bit of output, and in a production environment where Inotispy
is being used heavily it \fBis not\fR recommended that you have your log level
set to anything higher than \fBnotice\fR.
.P
See the comments in \fBetc/inotispy.conf\fR for more details.
.SH LANGUAGE BINDINGS
Inotispy provides an interface sutable for calling from programs in any language.
Included with the Inotispy distribution are code samples with examples
in several different languages. However, because this daemon is built on top of
.BR ZeroMQ
the best alternative resource would be the
.BR zmq (7)
documentation itself.
.PP
At the time of this writing Inotispy does not have any official bindings, however
because there are \fBZeroMQ\fR bindings in many popular languages it shouldn't be
difficult to roll a solution of your own.
.SH BUGS
Inotispy \fBdoes not\fR work on \fBXFS\fR. This is because XFS does not support
\fBdirent::d_type\fR. See link:
.P
.RS 4
.I http://nerdfortress.com/2008/09/19/linux-xfs-does-not-support-direntd_type/
.RE
.P
Eventually Inotispy should (and will) include a hook to determine the file
system it's it's being requested to watch and use
.BR stat (2)
instead of \fBdirent::d_type\fR to differentiate directories from regular files.
This does, however, have serious performance implications when watching large
directory trees as it adds a call to \fBstat()\fR for every single file found
while performing a recursive watch.
.P
So while we can (and will) make Inotispy work on XFS the reality is that it wont
perform well on large trees and the recommendation will be to not run Inotispy
on XFS.
.SH RESOURCES
Main web site:
.BR http://www.inotispy.org
.PP
Report bugs directly to anyone in the \fBAUTHORS\fR section below.
.SH SEE ALSO
.BR inotispyctl (8),
.BR zmq (7),
.BR inotify (7)
.SH AUTHORS
James Conerly <james@jamesconerly.com>
