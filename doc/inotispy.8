.\" Copyright (c) 2011-*, James Conerly <james@jamesconerly.com>
.\"
.\" Permission to use, copy, modify, and/or distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.TH "INOTISPY" "8" "21 September 2011" "Inotispy 1\&.0\&.1" "Inotispy Manual"
.SH NAME
inotispy \- efficient inotify daemon
.SH SYNOPSIS
.B inotispy [options]
.SH DESCRIPTION
Inotispy is an efficient file system change notification daemon built on top
of the
.BR inotify
kernel module. It recursively watches directory trees, queues file system
events that occur within those trees, and delivers those events to client
applications via
.BR ZeroMQ
sockets.
.PP
Inotispy is written in the C programmaing language and was tested against
.BR valgrind (1)
for memory leaks.
.SH OPTIONS
Inotispy doesm't have very many command line options. If you are interested
in further changing the behavior of Inotispy please see the \fBCONFIGURATION
FILE\fR section below.
.PP
\fB\-h\fR, \fB\-\-help\fR
.RS 4
Print the help menu.
.RE
\fB\-s\fR, \fB\-\-silent\fR
.RS 4
Run silently, and only messages will be appended to the log file. Inotispy
prints \fIvery little\fR to stderr and only does so at start up. So this
feature isn't very useful unless it's important that it runs with nothing
printed to the terminal.
.RE
.SH INOTISPY OVERVIEW
The \fBInotispy\fR daemon provides a service oriented interface for watching
directory trees on your file system for events. These are events like file
creation, deletion, move, permission changes, etc. Its interface and control
flow are designed to be as simple as possible. Essentially all a client does
is:
.P
.in +4n
.nf
\fBwatch\fR--->\fBconsume\fR-.->\fBunwatch\fR
      ^          |
      |__________|
.fi
.in
.P
Inotispy's main goal is to make it so that you, the coder, the one with
the file system monitoring project, can hook into inotify without having
to write your own code to recursively watch directories, manage mappings
between paths and watch descriptors, and handle event queuing. 
.P
Also, since Inotispy is a service it means that it is completely decoupled
from your application. This means that you can bring your application down
for maintenance or a code release and you won't lose the events from the
directory trees your application was watching.
.P
Communication with Inotispy is done through \fBZeroMQ\fR sockets and the protocol
is \fBJSON\fR. Each JSON request must contain a \fIcall\fR field and then a set
of required and optional arguments depending on the call.
.SS Calls
Calls to Inotispy are incredibly simple. An example call in JSON would look like:
.P
.in +4n
.nf
{
    "call" : "watch",
    "path" : "/foo/bar"
}
.fi
.in
.P
See the \fBINOTISPY API\fR section below for the full list of calls and their arguments.
.SS Responses
Responses from Inotispy are also JSON and they come in 3 flavors: \fBsuccess\fR,
\fBerror\fR, and \fBdata\fR.
.P
\fIsuccess\fR
.P
The \fBsuccess\fR response is actually pretty useless. This is the response you get
when you tell Inotispy to \fIwatch\fR or \fIunwatch\fR a directory tree and it
successfully kicks off the routine that recursively watches (or unwatches) your
tree. As a client, what you're more interested in is an \fBerror\fR response.
It looks like:
.P
.RS 4
{ "success" : 1 }
.RE
.P
\fIerror\fR
.P
The \fBerror\fR response tells you that something went wrong with your request,
naturally, by returning you an \fBerror code\fR and an \fBerror message\fR. Since
any of the calls can generate an error a client should \fIalways\fR first check
the response to see if it contains an \fBerror\fR field, and then react accordingly.
It looks like:
.P
.in +4n
.nf
{
    "error" : {
        "code" : 124,
        "message" : "Foo failed because of bar"
    }
}
.fi
.in
.P
\fIdata\fR
.P
The \fBdata\fR response is what you get when you request information from Inotispy,
such as a call to \fBget_roots\fR or \fBget_events\fR. This will be a hash with one
key, \fIdata\fR, whose value is an array containing the data you requested\fB**\fR.
In the case of \fBget_roots\fR it will be an array of pathnames (strings). In the
case of \fBget_events\fR it will be an array of hashes where each hash contains the
data of an inotify event. (See \fBINOTISPY_API\fR below for more information). It
looks like:
.P
.in +4n
.nf
{
    "data" : [
        "/foo/bar",
        "/baz/bing/bong"
    ]
}
.fi
.in
.P
\fB**\fR The one exception to this is a call to \fBget_queue_size\fR where the
value of the data field is an integer, not an array, which will look like:
.P
.in +4n
.nf
{ "data" : 42 }
.fi
.in
.P
.SH INOTISPY API
.P
Here be thy list of supported calls.
.P
.SS watch
Watch a new directory tree.
.P
\fIRequired Arguments\fR
.br
\fBpath\fR       - Absolute path of the new directory tree you want to watch.
.P
\fIOptional Arguments\fR
.br
\fBmask\fR       - Inotify mask defining the events\fB*\fR you're interested in.\fB**\fR
.br
\fBmax_events\fR - Max number of inotify events to queue for this root. (default=65536)
.P
\fIReturn Value\fR
.br
\fBsuccess\fR or \fBerror\fR
.P
\fIExample\fR
.P
.RS 4
{ "call" : "watch", "path" : "/foo/bar", "mask": 1024, "max_events" : 1000 }
.RE
.P
\fB*\fR If you don't supply your own mask Inotify provides a default mask for you.
The events in the default mask are:
.P
.in +4n
\fB
.nf
IN_ATTRIB
IN_MOVED_FROM
IN_MOVED_TO
IN_CREATE
IN_CLOSE_WRITE
IN_DELETE
IN_UNMOUNT
IN_DONT_FOLLOW
.fi
\fR
.in
.P
\fB**\fR See \fBinotify(7)\fR for more information on inotify events. A simple
(non-working) example in \fBC\fR for using a custom mask would look something like:
.P
.in +4n
.nf
#include <zmq.h>
#include <stdio.h>
#include <sys/inotify.h>

int
main (void) {
    uint32_t mask;
    char *json;
    char *path = "/foo/bar";

    /* Let's just watch for create and delete events */
    mask = IN_CREATE | IN_DELETE;

    asprintf(&json,
        "{\\"call\\":\\"watch\\",\\"path\\":%s,\\"mask\\":%d}",
        path, mask);

    /* Make 0MQ message from the 'json' variable here */

    zmq_send(socket, &msg, 0);
}
.fi
.in
.SS unwatch
Unwatch a currently watched directory tree.
.P
\fIRequired Arguments\fR
.br
\fBpath\fR - Absolute path of the root you want to unwatch.
.P
\fIReturn Value\fR
.br
\fBsuccess\fR or \fBerror\fR
.P
\fIExample\fR
.P
.RS 4
{ "call" : "unwatch", "path" : "/foo/bar" }
.RE
.P
.SS get_roots
Get the list of currently watched roots (directory trees).
.P
\fIThis function takes NO arguments\fR
.P
\fIReturn Value\fR
.br
\fBdata\fR or \fBerror\fR
.P
\fIExample\fR
.P
.RS 4
{ "call" : "get_roots" }
.RE
.P
.SS get_queue_size
Get the number of events in a given root's queue.
.P
\fIRequired Arguments\fR
.br
\fBpath\fR - Absolute path of the root you wish to query.
.P
\fIReturn Value\fR
.br
\fBdata\fR or \fBerror\fR
.P
\fIExample\fR
.P
.RS 4
{ "call" : "get_queue_size", "path" : "/foo/bar" }
.RE
.P
.SS get_events
Retrieve inotify events from a given root's queue.
.P
\fIRequired Arguments\fR
.br
\fBpath\fR  - Absolute path of the root you wish to retrieve events from.
.P
\fIOptional Arguments\fR
.br
\fBcount\fR - Number of events you want to retrieve.\fB*\fR
.P
\fIReturn Value\fR
.br
\fBdata\fR or \fBerror\fR
.P
\fIExample\fR
.P
.RS 4
{ "call" : "get_events", "path" : "/foo/bar", "count" : 10 }
.RE
.P
\fB*\fR Using a value of 0 (zero) will retrieve \fIall\fR events from
that root's queue.
.P
.SH ERRORS
When Inotispy returns an error it provides a human understandable error message
along with the error code. However, for reference (and people writing bindings)
here are the defined error codes (from \fBsrc/reply.h\fR):
.P
.in +4n
.nf
#define \fBERROR_JSON_INVALID\fR             0x0001 
#define \fBERROR_JSON_PARSE\fR               0x0002
#define \fBERROR_JSON_KEY_NOT_FOUND\fR       0x0004
#define \fBERROR_INOTIFY_WATCH_FAILED\fR     0x0008
#define \fBERROR_INOTIFY_UNWATCH_FAILED\fR   0x0010
#define \fBERROR_INVALID_EVENT_COUNT\fR      0x0020
#define \fBERROR_ZERO_BYTE_MESSAGE\fR        0x0040
#define \fBERROR_INOTIFY_ROOT_NOT_WATCHED\fR 0x0080
#define \fBERROR_ZEROMQ_RECONNECT\fR         0x0100
#define \fBERROR_NOT_ABSOLUTE_PATH\fR        0x0200
.fi
.in
.SH EXAMPLES
For examples on writing a client to talk to Inotispy please take a look at the
\fBexamples/\fR directory that ships with the distribution. There are examples
in several languages, including \fBC\fR and \fBPerl\fR.
.P
If you're writing your client code in \fBC\fR a full blown example is
\fBbin/inotispyctl.c\fR. 
.SH CONFIGURATION FILE
Inotispy ships with a small configuration file that you can use to modify a few
of it's characteristics. The config file that comes with the distribution
(\fBetc/inotispy.conf\fR) is thoroughly documented and it's full contents will
not be repeated here. However, here is the high level rundown of the parameters
you can tweak:
.P
.RS 4
\fBsilent\fR             - toggle printing to stderr
.br
\fBport\fR               - set your own port
.br
\fBlog_file\fR           - path to log file
.br
\fBlog_level\fR          - set the verbosity of logging
.br
\fBmax_inotify_events\fR - cap the number of per/root inotify events to be queued
.RE
.SH LOGGING
Inotispy outputs runtime information to a log file. The default location is
\fB/var/log/inotispy.log\fR. Using the configuration file (described above) you
can set the level of verbosity using the \fIlog_level\fR config parameter. By 
default the level is set to \fBnotice\fR, which should make the output fairly
limited.
.P
If you want, or need, to see more of what's going on under the hood then change
that level to \fBdebug\fR or \fBtrace\fR. Just be warned that these two levels
can produce quite a bit of output, and in a production environment where Inotispy
is being used heavily it \fBis not\fR recommended that you have your log level
set to this amount of verbosity.
.P
See \fBetc/inotispy.conf\fR for more details.
.SH LANGUAGE BINDINGS
Inotispy provides an interface sutable for calling from programs in any language.
Included with the Inotispy distribution are code samples with examples
in several different languages. However, because this daemon is built on top of
.BR ZeroMQ
the best alternative resource would be the
.BR zmq (7)
documentation itself.
.PP
At the time of this writing Inotispy does not have any official bindings, however
because there are \fBZeroMQ\fR bindings in many popular languages it shouldn't be
difficult to roll a solution of your own.
.SH BUGS
Inotispy \fBdoes not\fR work on \fBXFS\fR. This is because XFS does not support
\fBdirent::d_type\fR. See link:
.P
.RS 4
.I http://nerdfortress.com/2008/09/19/linux-xfs-does-not-support-direntd_type/
.RE
.P
Eventually Inotispy should (and will) include a hook to determine the file
system it's it's being requested to watch and use
.BR stat (2)
instead of \fBdirent::d_type\fR to differentiate directories from regular files.
This does, however, have serious performance implications when watching large
directory trees as it adds a call to \fBstat()\fR for every single file found
while performing a recursive watch.
.P
So while we can (and will) make Inotispy work on XFS the reality is that it wont
perform well on large trees and the recommendation will be to not run Inotispy
on XFS.
.SH RESOURCES
Main web site:
.BR http://www.inotispy.org
.PP
Report bugs directly to anyone in the \fBAUTHORS\fR section below.
.SH SEE ALSO
.BR inotispyctl (8),
.BR zmq (7),
.BR inotify (7)
.SH AUTHORS
James Conerly <james@jamesconerly.com>
